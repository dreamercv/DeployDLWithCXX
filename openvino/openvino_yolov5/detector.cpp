#include "detector.hpp"

void Detector::init()
{
    _cof_threshold = 0.1; //置信度阈值,计算方法是框置信度乘以物品种类置信度
    _nms_area_threshold = 0.1;
    LoadNetworkFromFile("/home/openvino_yolov5/models/yolov5s.xml",
                        "/home/openvino_yolov5/models/yolov5s.bin");
}

int Detector::LoadNetworkFromFile(const std::string &xml_path, const std::string &bin_path, std::string platform)
{
    // --------------------------- Load inference engine instance -------------------------------------
    const std::string device_name{platform};
    //    m_ie.AddExtension(std::make_shared<Extensions::Cpu::CpuExtensions>(), device_name);

    // --------------------------- Read IR Generated by ModelOptimizer (.xml and .bin files) ------------
    auto cnnNetwork = m_ie.ReadNetwork(xml_path);

    // --------------------------- Prepare input blobs -----------------------------------------------------
    InputsDataMap inputInfo(cnnNetwork.getInputsInfo());
    InputInfo::Ptr &input = inputInfo.begin()->second;
    _input_name = inputInfo.begin()->first;
    input->setPrecision(Precision::FP32);
    input->getInputData()->setLayout(Layout::NCHW);
    ICNNNetwork::InputShapes inputShapes = cnnNetwork.getInputShapes();
    SizeVector &inSizeVector = inputShapes.begin()->second;
    cnnNetwork.reshape(inputShapes);

    // --------------------------- Prepare output blobs ----------------------------------------------------
    _outputinfo = OutputsDataMap(cnnNetwork.getOutputsInfo());
    for (auto &output : _outputinfo)
    {
        output.second->setPrecision(Precision::FP32);
    }

    // --------------------------- Loading model to the device ------------------------------------------
    _network = m_ie.LoadNetwork(cnnNetwork, device_name);
}

void Detector::ForwardNetwork(const cv::Mat &in_mat, std::vector<result> &detections)
{
    //    std::cout<<"========================================="<<std::endl;
    int STANDARD_SIZE = 640;
    cv::Mat image;
    cv::resize(in_mat, image, cv::Size(STANDARD_SIZE, STANDARD_SIZE));
    cvtColor(image, image, COLOR_BGR2RGB);
    size_t img_size = STANDARD_SIZE * STANDARD_SIZE;
    InferRequest::Ptr infer_request = _network.CreateInferRequestPtr();
    Blob::Ptr frameBlob = infer_request->GetBlob(_input_name);
    InferenceEngine::LockedMemory<void> blobMapped = InferenceEngine::as<InferenceEngine::MemoryBlob>(frameBlob)->wmap();
    float *blob_data = blobMapped.as<float *>();
    //nchw
    for (size_t row = 0; row < STANDARD_SIZE; row++)
    {
        for (size_t col = 0; col < STANDARD_SIZE; col++)
        {
            for (size_t ch = 0; ch < 3; ch++)
            {
                blob_data[img_size * ch + row * STANDARD_SIZE + col] = float(image.at<Vec3b>(row, col)[ch]) / 255.0f;
            }
        }
    }
    //执行预测
    infer_request->Infer();
    //获取各层结果
    vector<Rect> origin_rect;
    vector<float> origin_rect_cof;
    vector<int> idxs;
    int s[3] = {80, 40, 20};

    int i = 0;
    for (auto &output : _outputinfo)
    {
        auto output_name = output.first;
        Blob::Ptr blob = infer_request->GetBlob(output_name);
        parse_yolov5(blob, s[i], _cof_threshold, origin_rect, origin_rect_cof, idxs);
        ++i;
    }
    //后处理获得最终检测结果
    vector<int> final_id;
    dnn::NMSBoxes(origin_rect, origin_rect_cof, _cof_threshold, _nms_area_threshold, final_id);
    for (int i = 0; i < final_id.size(); ++i)
    {
        double conf;
        int class_id;
        cv::Rect resize_rect = origin_rect[final_id[i]];
        detections.push_back({resize_rect, class_id, conf});
        /* code */
    }
}

//注意此处的阈值是框和物体prob乘积的阈值
bool Detector::parse_yolov5(const Blob::Ptr &blob, int net_grid, float cof_threshold,
                            vector<Rect> &o_rect, vector<float> &o_rect_cof, vector<int> &idxs)
{
    vector<int> anchors = get_anchors(net_grid);
    LockedMemory<const void> blobMapped = as<MemoryBlob>(blob)->rmap();
    const float *output_blob = blobMapped.as<float *>();
    //80个类是85,一个类是6,n个类是n+5
    //int item_size = 6;
    int item_size = 85;
    size_t anchor_n = 3;
    for (int n = 0; n < anchor_n; ++n)
        for (int i = 0; i < net_grid; ++i)
            for (int j = 0; j < net_grid; ++j)
            {
                double box_prob = output_blob[n * net_grid * net_grid * item_size + i * net_grid * item_size + j * item_size + 4];
                box_prob = sigmoid(box_prob);
                //框置信度不满足则整体置信度不满足
                if (box_prob < cof_threshold)
                    continue;

                //注意此处输出为中心点坐标,需要转化为角点坐标
                double x = output_blob[n * net_grid * net_grid * item_size + i * net_grid * item_size + j * item_size + 0];
                double y = output_blob[n * net_grid * net_grid * item_size + i * net_grid * item_size + j * item_size + 1];
                double w = output_blob[n * net_grid * net_grid * item_size + i * net_grid * item_size + j * item_size + 2];
                double h = output_blob[n * net_grid * net_grid * item_size + i * net_grid * item_size + j * item_size + 3];

                double max_prob = 0;
                int idx = 0;
                for (int t = 5; t < item_size; ++t)
                {
                    double tp = output_blob[n * net_grid * net_grid * item_size + i * net_grid * item_size + j * item_size + t];
                    tp = sigmoid(tp);
                    if (tp > max_prob)
                    {
                        max_prob = tp;
                        idx = t;
                    }
                }
                float cof = box_prob * max_prob;
                //对于边框置信度小于阈值的边框,不关心其他数值,不进行计算减少计算量
                if (cof < cof_threshold)
                    continue;

                x = (sigmoid(x) * 2 - 0.5 + j) * 640.0f / net_grid;
                y = (sigmoid(y) * 2 - 0.5 + i) * 640.0f / net_grid;
                w = pow(sigmoid(w) * 2, 2) * anchors[n * 2];
                h = pow(sigmoid(h) * 2, 2) * anchors[n * 2 + 1];

                double r_x = x - w / 2;
                double r_y = y - h / 2;
                Rect rect = Rect(round(r_x), round(r_y), round(w), round(h));
                o_rect.push_back(rect);
                o_rect_cof.push_back(cof);
                idxs.push_back(idx);
            }
    if (o_rect.size() == 0)
        return false;
    else
        return true;
}

//以下为工具函数
double Detector::sigmoid(double x)
{
    return (1 / (1 + exp(-x)));
}

vector<int> Detector::get_anchors(int net_grid)
{
    vector<int> anchors(6);
    int a80[6] = {10, 13, 16, 30, 33, 23};
    int a40[6] = {30, 61, 62, 45, 59, 119};
    int a20[6] = {116, 90, 156, 198, 373, 326};
    if (net_grid == 80)
    {
        anchors.insert(anchors.begin(), a80, a80 + 6);
    }
    else if (net_grid == 40)
    {
        anchors.insert(anchors.begin(), a40, a40 + 6);
    }
    else if (net_grid == 20)
    {
        anchors.insert(anchors.begin(), a20, a20 + 6);
    }
    return anchors;
}
